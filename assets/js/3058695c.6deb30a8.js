"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3350],{7227:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});t(96540);var a=t(34164);const o={tabItem:"tabItem_Ymn6"};var r=t(74848);function i({children:e,hidden:n,className:t}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,a.A)(o.tabItem,t),hidden:n,children:e})}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var a=t(96540);const o={},r=a.createContext(o);function i(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:n},e.children)}},49489:(e,n,t)=>{t.r(n),t.d(n,{default:()=>w});var a=t(96540),o=t(34164),r=t(18630),i=t(24245),s=t(56347),l=t(36494),c=t(62814),d=t(45167),p=t(69900);function u(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function _(e){const{values:n,children:t}=e;return(0,a.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:t,default:a}})=>({value:e,label:n,attributes:t,default:a}))}(t);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function h({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const t=(0,s.W6)(),o=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(o),(0,a.useCallback)(e=>{if(!o)return;const n=new URLSearchParams(t.location.search);n.set(o,e),t.replace({...t.location,search:n.toString()})},[o,t])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,r=_(e),[i,s]=(0,a.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r})),[c,d]=m({queryString:t,groupId:o}),[u,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,o]=(0,p.Dv)(n);return[t,(0,a.useCallback)(e=>{n&&o.set(e)},[n,o])]}({groupId:o}),g=(()=>{const e=c??u;return h({value:e,tabValues:r})?e:null})();(0,l.A)(()=>{g&&s(g)},[g]);return{selectedValue:i,selectValue:(0,a.useCallback)(e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);s(e),d(e),f(e)},[d,f,r]),tabValues:r}}var g=t(11062);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function j({className:e,block:n,selectedValue:t,selectValue:a,tabValues:r}){const s=[],{blockElementScrollPositionUntilNextRender:l}=(0,i.a_)(),c=e=>{const n=e.currentTarget,o=s.indexOf(n),i=r[o].value;i!==t&&(l(n),a(i))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=s.indexOf(e.currentTarget)+1;n=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(e.currentTarget)-1;n=s[t]??s[s.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},e),children:r.map(({value:e,label:n,attributes:a})=>(0,b.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{s.push(e)},onKeyDown:d,onClick:c,...a,className:(0,o.A)("tabs__item",v.tabItem,a?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function k({lazy:e,children:n,selectedValue:t}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===t);return e?(0,a.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function x(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,o.A)(r.G.tabs.container,"tabs-container",v.tabList),children:[(0,b.jsx)(j,{...n,...e}),(0,b.jsx)(k,{...n,...e})]})}function w(e){const n=(0,g.default)();return(0,b.jsx)(x,{...e,children:u(e.children)},String(n))}},74006:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>_,frontMatter:()=>l,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"data_utilities/core_code_snippets/mps","title":"MPS - General","description":"Project Aria Machine Perception Services (MPS) enables Aria users with access to the Aria Research Kit to request derived data on Aria VRS files.","source":"@site/docs/data_utilities/core_code_snippets/mps.mdx","sourceDirName":"data_utilities/core_code_snippets","slug":"/data_utilities/core_code_snippets/mps","permalink":"/projectaria_tools/docs/data_utilities/core_code_snippets/mps","draft":false,"unlisted":false,"editUrl":"https://github.com/facebookresearch/projectaria_tools/tree/main/website/docs/data_utilities/core_code_snippets/mps.mdx","tags":[],"version":"current","sidebarPosition":40,"frontMatter":{"sidebar_position":40,"title":"MPS - General"},"sidebar":"tutorialSidebar","previous":{"title":"Calibration","permalink":"/projectaria_tools/docs/data_utilities/core_code_snippets/calibration"},"next":{"title":"MPS - Eye Gaze","permalink":"/projectaria_tools/docs/data_utilities/core_code_snippets/eye_gaze_code"}}');var o=t(74848),r=t(28453),i=t(49489),s=t(7227);const l={sidebar_position:40,title:"MPS - General"},c="MPS Code Snippets",d={},p=[{value:"Load MPS output",id:"load-mps-output",level:2},{value:"Open loop/Closed loop trajectory",id:"open-loopclosed-loop-trajectory",level:3},{value:"Point cloud",id:"point-cloud",level:3},{value:"Online calibration",id:"online-calibration",level:3},{value:"Hand Tracking",id:"hand-tracking",level:3}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"mps-code-snippets",children:"MPS Code Snippets"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/projectaria_tools/docs/ARK/mps/",children:"Project Aria Machine Perception Services (MPS)"})," enables Aria users with access to the ",(0,o.jsx)(n.a,{href:"https://www.projectaria.com/research-kit/",children:"Aria Research Kit"})," to request derived data on Aria VRS files."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/projectaria_tools/docs/open_datasets/",children:"Open Datasets"})," also contain ",(0,o.jsx)(n.a,{href:"/projectaria_tools/docs/data_formats/mps/mps_summary",children:"MPS outputs"})," and may have specific tools to use and visualize their data."]}),"\n",(0,o.jsx)(n.p,{children:"This page covers how to consume standard MPS outputs."}),"\n",(0,o.jsx)(n.h2,{id:"load-mps-output",children:"Load MPS output"}),"\n",(0,o.jsxs)(n.p,{children:["The loaders for MPS outputs (",(0,o.jsx)(n.a,{href:"https://github.com/facebookresearch/projectaria_tools/blob/main/core/mps",children:"projectaria_tools/main/core/mps"}),") make it easer to use the data downstream. As part of this, the loaders put the outputs into data structures that are easier for other tools to consume."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/projectaria_tools/docs/data_formats/mps/mps_summary",children:"MPS Data Formats"})," provides details about output schemas and the specifics of each MPS output. This page focuses loading APIs in Python and C++, where there isn't a standalone code samples page:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"eye_gaze_code",children:"Eye Gaze Code Samples"})}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"open-loopclosed-loop-trajectory",children:"Open loop/Closed loop trajectory"}),"\n",(0,o.jsxs)(i.default,{groupId:"programming-language",children:[(0,o.jsx)(s.default,{value:"python",label:"Python",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import projectaria_tools.core.mps as mps\n\nopen_loop_path = "/path/to/mps/output/trajectory/open_loop_trajectory.csv"\nopen_loop_traj = mps.read_open_loop_trajectory(open_loop_path)\n\nclosed_loop_path = "/path/to/mps/output/trajectory/closed_loop_trajectory.csv"\nclosed_loop_traj = mps.read_closed_loop_trajectory(closed_loop_path)\n\n# example: get transformation from this device to a world coordinate frame\nfor closed_loop_pose in closed_loop_traj:\n    transform_world_device = closed_loop_pose.transform_world_device\n\n# example: query to find the closest Timestamp device pose and move it to the Aria RGB camera pose\nfrom projectaria_tools.core import data_provider\nfrom projectaria_tools.core.mps.utils import get_nearest_pose\nfrom projectaria_tools.core.stream_id import StreamId\n\nquery_timestamp_ns = int(closed_loop_traj[1].tracking_timestamp.total_seconds() * 1e9) # to be updated with your VRS timestamps\n\npose_info = get_nearest_pose(closed_loop_traj, query_timestamp_ns)\nif pose_info:\n    T_world_device = pose_info.transform_world_device\n\n    # Move this pose to the Project Aria RGB camera\n    vrs_file = "example.vrs"\n    vrs_data_provider = data_provider.create_vrs_data_provider(vrs_file)\n    rgb_stream_id = StreamId("214-1")\n    rgb_stream_label = vrs_data_provider.get_label_from_stream_id(rgb_stream_id)\n    device_calibration = vrs_data_provider.get_device_calibration()\n    rgb_camera_calibration = device_calibration.get_camera_calib(rgb_stream_label)\n\n    T_device_rgb_camera = rgb_camera_calibration.get_transform_device_camera()\n    T_world_rgb_camera = T_world_device @ T_device_rgb_camera\n\n    print(T_world_rgb_camera)\n'})})}),(0,o.jsx)(s.default,{value:"cpp",label:"C++",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'#include <TrajectoryReaders.h>\nusing namespace projectaria::tools::mps;\n\nstd::string openLoopTrajPath = "/path/to/mps/output/trajectory/open_loop_trajectory.csv";\nOpenLoopTrajectory openLoopTraj = readOpenLoopTrajectory(openLoopTrajPath);\n\nstd::string closedLoopTrajPath = "/path/to/mps/output/trajectory/closed_loop_trajectory.csv";\nClosedLoopTrajectory closedLoopTraj = readClosedLoopTrajectory(closedLoopTrajPath);\n\n// example: get transformation from this device to world coordinate frame\nfor (const ClosedLoopTrajectoryPose& closedLoopPose : closedLoopTraj) {\n    const Sophus::SE3d& T_world_device = closedLoopPose.T_world_device;\n}\n'})})})]}),"\n",(0,o.jsx)(n.h3,{id:"point-cloud",children:"Point cloud"}),"\n",(0,o.jsx)(n.admonition,{title:"Always filter global point clouds in 3D",type:"info",children:(0,o.jsxs)(n.p,{children:["Post-filtering the point cloud using inverse distance and distance certainty is required to get point cloud ",(0,o.jsx)(n.strong,{children:"accurate in 3D space"}),". There are points cannot be accurately estimated in 3D space due to low parallax, but those points are well tracked in 2D images, and produce valid 2D observations. We choose to output ",(0,o.jsx)(n.strong,{children:"all"})," the points, include those have poor 3D estimations, in case researchers need them. Go to the ",(0,o.jsx)(n.a,{href:"/projectaria_tools/docs/data_formats/mps/slam/mps_pointcloud",children:"Semi-Dense Point Cloud page"})," for more information."]})}),"\n",(0,o.jsx)(n.admonition,{title:"Loading observations could be slow",type:"info",children:(0,o.jsx)(n.p,{children:"When the Aria recording is long, loading point observations could be memory and time consuming (> 1 minute). A typical 20 minutes long Aria recording will have roughly total 10+ millions of 3D points with total 100+ millions of 2D observations."})}),"\n",(0,o.jsxs)(i.default,{groupId:"programming-language",children:[(0,o.jsx)(s.default,{value:"python",label:"Python",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import projectaria_tools.core.mps as mps\nfrom projectaria_tools.core.mps.utils import filter_points_from_confidence\n\nglobal_points_path = "/path/to/mps/output/trajectory/semidense_points.csv.gz"\npoints = mps.read_global_point_cloud(global_points_path)\n\n# filter the point cloud using thresholds on the inverse depth and distance standard deviation\ninverse_distance_std_threshold = 0.001\ndistance_std_threshold = 0.15\n\nfiltered_points = filter_points_from_confidence(points, inverse_distance_std_threshold, distance_std_threshold)\n\n# example: get position of this point in the world coordinate frame\nfor point in filtered_points:\n    position_world = point.position_world\n\nobservations_path = "/path/to/mps/output/trajectory/semidense_observations.csv.gz"\nobservations = mps.read_point_observations(observations_path)\n'})})}),(0,o.jsx)(s.default,{value:"cpp",label:"C++",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'#include <GlobalPointCloudFilter.h>\n#include <GlobalPointCloudReader.h>\n#include <PointObservationReader.h>\n\nusing namespace projectaria::tools::mps;\n\nstd::string globalPointsPath = "/path/to/mps/output/trajectory/open_loop_trajectory.csv";\nGlobalPointCloud points = readGlobalPointCloud(globalPointsPath);\n\n// filter the point cloud by inverse depth and depth\nconst float inverseDistanceStdThreshold = 0.001;\nconst float distanceStdThreshold = 0.15;\nGlobalPointCloud filteredPoints = filterPointsFromConfidence(points, inverseDistanceStdThreshold, distanceStdThreshold);\n\n// example: get the position of this point in the world coordinate frame\nfor (const GlobalPointPosition& point : filteredPoints) {\n    const Eigen::Vector3d& position_world = point.position_world;\n}\n\nstd::string observationsPath = "/path/to/mps/output/trajectory/semidense_observations.csv.gz";\nPointObservations observations = readPointObservations(observationsPath);\n'})})})]}),"\n",(0,o.jsx)(n.h3,{id:"online-calibration",children:"Online calibration"}),"\n",(0,o.jsxs)(i.default,{groupId:"programming-language",children:[(0,o.jsx)(s.default,{value:"python",label:"Python",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import projectaria_tools.core.mps as mps\n\nonline_calib_path = "/path/to/mps/output/trajectory/online_calibration.jsonl"\nonline_calibs = mps.read_online_calibration(online_calib_path)\n\nfor calib in online_calibs:\n    # example: get left IMU\'s online calibration\n    for imuCalib in calib.imu_calibs:\n        if imuCalib.get_label() == "imu-left":\n            leftImuCalib = imuCalib\n    # example: get left SLAM camera\'s online calibration\n    for camCalib in calib.camera_calibs:\n        if camCalib.get_label() == "camera-slam-left":\n            leftCamCalib = camCalib\n'})})}),(0,o.jsx)(s.default,{value:"cpp",label:"C++",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'#include <OnlineCalibrationsReader.h>\nusing namespace projectaria::tools::calibration;\nusing namespace projectaria::tools::mps;\n\nstd::string onlineCalibPath = "/path/to/mps/output/trajectory/online_calibration.jsonl";\nOnlineCalibrations onlineCalibs = readOnlineCalibration(onlineCalibPath);\n\nfor (const OnlineCalibration& calib : onlineCalibs) {\n    // example: get left IMU\'s online calibration\n    for (const ImuCalibration& imuCalib : calib.imuCalibs) {\n        if (imuCalib.getLabel() == "imu-left") {\n            const ImuCalibration& leftImuCalib = imuCalib;\n        }\n    }\n    // example: get left SLAM camera\'s online calibration\n    for (const CameraCalibration& camCalib : calib.cameraCalibs) {\n        if (camCalib.getLabel() == "camera-slam-left") {\n            const CameraCalibration& leftCamCalib = camCalib;\n        }\n    }\n}\n'})})})]}),"\n",(0,o.jsx)(n.h3,{id:"hand-tracking",children:"Hand Tracking"}),"\n",(0,o.jsxs)(i.default,{groupId:"programming-language",children:[(0,o.jsx)(s.default,{value:"python",label:"Python",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import projectaria_tools.core.mps as mps\nfrom projectaria_tools.core.mps.utils import get_nearest_hand_tracking_result\n\n\n## Load hand tracking results\nhand_tracking_results_path = "/path/to/mps/output/hand_tracking/hand_tracking_results.csv"\nhand_tracking_results = mps.hand_tracking.read_hand_tracking_results(\n    hand_tracking_results_path\n)\n\n\n# Example query: find the nearest hand tracking data outputs in relation to a specific timestamp\nhand_tracking_result = get_nearest_hand_tracking_result(\n    hand_tracking_results, query_timestamp_ns\n)\n\n\n# Get left and right-hand confidences, landmarks wrist and palm positions and normals in the device frame. Note that if hands are not found, per-hand result is None.\n# Left-hand side\nif hand_tracking_result.left_hand:\n    left_pose_confidence = hand_tracking_result.left_hand.confidence\n    left_landmark_positions_device = hand_tracking_result.left_hand.landmark_positions_device\n    left_transform_device_wrist = hand_tracking_result.left_hand.transform_device_wrist\n\n    # Use helper functions to get wrist and palm positions in the device frame\n    left_wrist_position_device = hand_tracking_result.left_hand.get_wrist_position_device()\n    left_palm_position_device = hand_tracking_result.left_hand.get_palm_position_device()\n\n    if hand_tracking_result.left_hand.wrist_and_palm_normal_device:\n        left_wrist_normal_device = hand_tracking_result.left_hand.wrist_and_palm_normal_device.wrist_normal_device\n        left_palm_normal_device = hand_tracking_result.left_hand.wrist_and_palm_normal_device.palm_normal_device\n\n# Right-hand side\nif hand_tracking_result.right_hand:\n    right_pose_confidence = hand_tracking_result.right_hand.confidence\n    right_landmark_positions_device = hand_tracking_result.right_hand.landmark_positions_device\n    right_transform_device_wrist = hand_tracking_result.right_hand.transform_device_wrist\n\n    # Use helper functions to get wrist and palm positions in the device frame\n    right_wrist_position_device = hand_tracking_result.right_hand.get_wrist_position_device()\n    right_palm_position_device = hand_tracking_result.right_hand.get_palm_position_device()\n\n    if hand_tracking_result.right_hand.wrist_and_palm_normal_device:\n        right_wrist_normal_device = hand_tracking_result.right_hand.wrist_and_palm_normal_device.wrist_normal_device\n        right_palm_normal_device = hand_tracking_result.right_hand.wrist_and_palm_normal_device.palm_normal_device\n'})})}),(0,o.jsx)(s.default,{value:"cpp",label:"C++",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'#include <mps/HandTrackingReader.h>\n\nusing namespace projectaria::tools::mps;\n\nconst auto handTrackingResults = readHandTrackingResults("/path/to/mps/output/hand_tracking/hand_tracking_results.csv");\n\nfor (const auto& handTrackingResult: handTrackingResults) {\n  for (HANDEDNESS handedness : {HANDEDNESS::LEFT, HANDEDNESS::RIGHT}) {\n    const auto& perHandHandTrackingResult = handTrackingResult.value()[handedness];\n    if (!perHandHandTrackingResult ||\n        perHandHandTrackingResult->confidence < MIN_CONFIDENCE_) {\n      continue;\n    }\n\n    const auto& landmarksInDevice = perHandHandTrackingResult->landmarkPositions_device;\n    Landmarks landmarksInWorld;\n    landmarksInWorld.reserve(landmarksInDevice.size());\n    for (const auto& landmarkInDevice: landmarksInDevice) {\n        landmarksInWorld.emplace_back(T_World_Device.value() * landmarkInDevice);\n    }\n\n    // Use helper functions to get wrist and palm positions in the device frame\n    const auto& wristInDevice = perHandHandTrackingResult->getWristPositionInDevice();\n    const auto& palmInDevice = perHandHandTrackingResult->getPalmPositionInDevice();\n    const auto& wristInWorld = T_World_Device.value() * wristInDevice;\n    const auto& palmInWorld = T_World_Device.value() * palmInDevice;\n\n    if (perHandHandTrackingResult.wristAndPalmNormal_device.has_value()) {\n        const auto& wristNormalInDevice = perHandHandTrackingResult.wristAndPalmNormal_device->wristNormal_device;\n        const auto& palmNormalInDevice = perHandHandTrackingResult.wristAndPalmNormal_device->palmNormal_device;\n        const auto wristNormalInWorld = T_World_Device.value().so3() * wristNormal_device;\n        const auto palmNormalInWorld = T_World_Device.value().so3() * palmNormal_device;\n    }\n\n    const auto& T_Device_Wrist = perHandHandTrackingResult->T_Device_Wrist;\n  }\n}\n'})})})]})]})}function _(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);