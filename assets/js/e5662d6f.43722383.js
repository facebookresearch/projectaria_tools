"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6635],{3433:(e,a,t)=>{t.d(a,{A:()=>r});const r=t.p+"assets/images/color_correction-47381465eb3b5a8c38114831aef00e58.png"},7227:(e,a,t)=>{t.r(a),t.d(a,{default:()=>o});t(96540);var r=t(34164);const i={tabItem:"tabItem_Ymn6"};var n=t(74848);function o({children:e,hidden:a,className:t}){return(0,n.jsx)("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,t),hidden:a,children:e})}},22794:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>m});const r=JSON.parse('{"id":"data_utilities/advanced_code_snippets/image_utilities","title":"Image Utilities (Python and C++)","description":"Overview","source":"@site/docs/data_utilities/advanced_code_snippets/image_utilities.mdx","sourceDirName":"data_utilities/advanced_code_snippets","slug":"/data_utilities/advanced_code_snippets/image_utilities","permalink":"/projectaria_tools/docs/data_utilities/advanced_code_snippets/image_utilities","draft":false,"unlisted":false,"editUrl":"https://github.com/facebookresearch/projectaria_tools/tree/main/website/docs/data_utilities/advanced_code_snippets/image_utilities.mdx","tags":[],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20,"title":"Image Utilities (Python and C++)"},"sidebar":"tutorialSidebar","previous":{"title":"Plot Sensor Data (Python)","permalink":"/projectaria_tools/docs/data_utilities/advanced_code_snippets/plotting_sensor_data"},"next":{"title":"Export VRS to MP4 (Python)","permalink":"/projectaria_tools/docs/data_utilities/advanced_code_snippets/vrs_to_mp4"}}');var i=t(74848),n=t(28453),o=t(49489),l=t(7227);const s={sidebar_position:20,title:"Image Utilities (Python and C++)"},d="Advanced Image Utilities",c={},m=[{value:"Overview",id:"overview",level:2},{value:"Image debayer",id:"image-debayer",level:2},{value:"Image undistortion",id:"image-undistortion",level:2},{value:"Rotated image clockwise 90 degrees",id:"rotated-image-clockwise-90-degrees",level:2},{value:"Color Correction",id:"color-correction",level:2},{value:"Color Correction user recommendations",id:"color-correction-user-recommendations",level:3},{value:"Potential failure cases",id:"potential-failure-cases",level:3},{value:"Image devignetting",id:"image-devignetting",level:2}];function g(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"advanced-image-utilities",children:"Advanced Image Utilities"})}),"\n",(0,i.jsx)(a.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(a.p,{children:["This page provides advanced image utilities code snippets for Project Aria Tools, see also ",(0,i.jsx)(a.a,{href:"/docs/data_utilities/core_code_snippets/image",children:"Image Code Snippets"}),"."]}),"\n",(0,i.jsx)(a.h2,{id:"image-debayer",children:"Image debayer"}),"\n",(0,i.jsxs)(a.p,{children:["Some recording profiles outputs raw RGB images (Profile 7 in ",(0,i.jsx)(a.a,{href:"/docs/tech_spec/recording_profiles",children:"Recording Profile"}),"). We provide functionalities to debayer them and perform white-balancing to get RGB images."]}),"\n",(0,i.jsxs)(o.default,{groupId:"programming-language",children:[(0,i.jsx)(l.default,{value:"python",label:"Python",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-python",children:'from projectaria_tools.core import data_provider, image\n\nstream_id = provider.get_stream_id_from_label("camera-rgb")\nimage_data = provider.get_image_data_by_index(stream_id, 0)\nimage_data_array = image_data[0].to_numpy_array()\ndebayered_array = image.debayer(image_data_array)\n'})})}),(0,i.jsx)(l.default,{value:"cpp",label:"C++",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-cpp",children:'#include <dataprovider/VrsDataProvider.h>\n#include <image/utility/Debayer.h>\n\nauto streamId = provider.getStreamIdFromLabel("camera-rgb");\nauto imageData = provider.getImageDataByIndex(streamId, 0);\nauto debayeredImage = debayer(imageData.first.imageVariant());\n'})})})]}),"\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.img,{alt:"Image",src:t(85819).A+"",width:"912",height:"427"})}),"\n",(0,i.jsxs)(a.p,{children:["See ",(0,i.jsx)(a.a,{href:"https://github.com/facebookresearch/projectaria_tools/blob/main/core/image/utility/Debayer.cpp",children:"projectaria_tools/core/image/utility/Debayer.cpp"})," for implementation"]}),"\n",(0,i.jsx)(a.h2,{id:"image-undistortion",children:"Image undistortion"}),"\n",(0,i.jsx)(a.p,{children:"In this example, we remove distortions in raw sensor data so that straight 3D lines appear straight in the undistorted images. There is existing C++ implementation and Python wrapper of this helper function in the data utilities."}),"\n",(0,i.jsxs)(o.default,{groupId:"programming-language",children:[(0,i.jsx)(l.default,{value:"python",label:"Python",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-python",children:'from projectaria_tools.core import data_provider, calibration\n\ncamera_label = "camera-slam-left"\nstream_id = provider.get_stream_id_from_label(camera_label)\n\ncalib = provider.get_device_calibration().get_camera_calib(camera_label)\npinhole = calibration.get_linear_camera_calibration(512, 512, 150)\n\nraw_image = provider.get_image_data_by_index(stream_id, 0)[0].to_numpy_array()\nundistorted_image = calibration.distort_by_calibration(raw_image, pinhole, calib)\n'})})}),(0,i.jsx)(l.default,{value:"cpp",label:"C++",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-cpp",children:'#include <dataprovider/VrsDataProvider.h>\n#include <calibration/utility/Distort.h>\n\nstd::string cameraLabel = "camera-rgb";\nvrs::StreamId streamId = provider->getStreamIdFromLabel(cameraLabel);\n\nCameraCalibration calib = provider->getCameraCalibration(streamId);\nCameraCalibration pinhole = getLinearCameraCalibration(512, 512, 150);\n\nImageData rawImage = provider->getImageDataByIndex(streamId, 0);\nauto undistortedImage = distortByCalibration(rawImage.imageVariant(), pinhole, calib);\n'})})})]}),"\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.img,{alt:"Image",src:t(79317).A+"",width:"810",height:"403"})}),"\n",(0,i.jsxs)(a.p,{children:["Go to ",(0,i.jsx)(a.a,{href:"https://github.com/facebookresearch/projectaria_tools/blob/main/core/calibration/utility/Distort.cpp",children:"projectaria_tools/core/calibration/utility/Distort.cpp"})," for implementation."]}),"\n",(0,i.jsxs)(a.p,{children:["Go to the ",(0,i.jsx)(a.a,{href:"/projectaria_tools/docs/faq#calibration",children:"Project Aria FAQ"})," for more calibration information and resources."]}),"\n",(0,i.jsx)(a.h2,{id:"rotated-image-clockwise-90-degrees",children:"Rotated image clockwise 90 degrees"}),"\n",(0,i.jsx)(a.p,{children:"In this example, we rotated the RGB image 90 degrees and provide the new calibration object."}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"Calibration rotation only applies to pinhole camera model"}),"\n",(0,i.jsxs)(a.li,{children:["Pinhole camera calibration object needs to be initialized as ",(0,i.jsx)(a.code,{children:"pinhole = calibration.get_linear_camera_calibration(512, 512, 150, camera_label, calib.get_transform_device_camera())"}),"\nwith ",(0,i.jsx)(a.code,{children:"camera_label"})," and the pose ",(0,i.jsx)(a.code,{children:"calib.get_transform_device_camera()"})," so that ",(0,i.jsx)(a.code,{children:"pinhole_cw90"})," can have the correct transformation matrix when unprojecting a pixel to get ",(0,i.jsx)(a.code,{children:"ray_in_device_frame"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(o.default,{groupId:"programming-language",children:[(0,i.jsx)(l.default,{value:"python",label:"Python",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-python",children:'camera_label = "camera-rgb"\nstream_id = provider.get_stream_id_from_label(camera_label)\n\ncalib = provider.get_device_calibration().get_camera_calib(camera_label)\npinhole = calibration.get_linear_camera_calibration(512, 512, 150, camera_label,\ncalib.get_transform_device_camera())\n\nraw_image = provider.get_image_data_by_index(stream_id, 0)[0].to_numpy_array()\nundistorted_image = calibration.distort_by_calibration(raw_image, pinhole, calib)\n\n# Rotated image by CW90 degrees\nrotated_image = np.rot90(undistorted_image, k=3)\n\n# Get rotated image calibration\npinhole_cw90 = calibration.rotate_camera_calib_cw90deg(pinhole)\n\n# Unproject a pixel and get a ray from device coordinate frame\ntest_pixel_in_rotated_image = [10,0]\nray_in_device_frame =  pinhole_cw90.get_transform_device_camera() @ pinhole_cw90.unproject_no_checks(test_pixel_in_rotated_image)\n'})})}),(0,i.jsx)(l.default,{value:"cpp",label:"C++",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-cpp",children:'#include <dataprovider/VrsDataProvider.h>\n#include <calibration/utility/Distort.h>\n\nstd::string cameraLabel = "camera-rgb";\nvrs::StreamId streamId = provider->getStreamIdFromLabel(cameraLabel);\n\nCameraCalibration calib = provider->getCameraCalibration(streamId);\nCameraCalibration pinhole = getLinearCameraCalibration(512, 512, 150, cameraLabel, calib.getT_Device_Camera());\n\n// Get rotated image calibration\nCameraCalibration pinholeCW90 = rotatedCameraCalibCW90Deg(pinhole);\n\n// Unproject a pixel and get a ray from device coordinate frame\nEigen::Vector2d textPixelInRotatedImage{10,0};\nauto ray = pinholeCW90.getT_Device_Camera() * pinholeCW90.projectNoChecks(textPixelInRotatedImage);\n'})})})]}),"\n",(0,i.jsx)(a.h2,{id:"color-correction",children:"Color Correction"}),"\n",(0,i.jsx)(a.p,{children:"Videos and images taken with earlier versions of the Aria OS may show color distortion due to inconsistent gamma curves and unconventional color temperatures, leading to inconsistent and overly blue hues. To address this, we've introduced a Color Correction feature in the ARK v1.13 update. With this update, images captured by Aria devices now have more consistent colors and are calibrated to a standard color temperature of 5000K. We also recommend applying devignetting to the images to achieve more accurate image quality."}),"\n",(0,i.jsx)(a.h3,{id:"color-correction-user-recommendations",children:"Color Correction user recommendations"}),"\n",(0,i.jsx)(a.p,{children:"The new Color Correction feature is available as an option in data campaigns and the Companion App. It's enabled by default in the new Aria OS, and we recommend users utilize the feature for future Aria captures to achieve optimal image quality. We also suggest keeping existing images captured with the old Aria OS and combining them with new Aria captures for research purposes.\nFor advanced users, we provide a Color Correction API in Project Aria Tools that can correct color distortions in old captures and images. We advise using this API with caution for the following reasons:"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"The post-processing API can effectively convert and correct color distortion in older images, particularly in environments that are not overexposed. If your images do not contain overexposed areas, we recommend converting them for optimal image quality."}),"\n",(0,i.jsx)(a.li,{children:"If an image contains overexposed areas, the colors in the overexposed regions may be oversaturated due to distortion in color settings: this may make it impossible to accurately recover the proper colors, potentially resulting in artifacts. This is more common in outdoor environments, where oversaturated areas can appear around the sky or sun. In such cases, we recommend retaining the old images without converting them."}),"\n"]}),"\n",(0,i.jsx)(a.h3,{id:"potential-failure-cases",children:"Potential failure cases"}),"\n",(0,i.jsx)(a.p,{children:"The issue with overexposed captures is demonstrated in the picture below. In the left image, captured by the old Aria OS, the central area is oversaturated due to strong light around the sun, resulting in the loss of digital values above 255 for higher-range colors. These lost colors cannot be recovered. The middle image, where the old image has been color-corrected and devignetted, displays a yellowish tint after the color correction conversion due to the original image's oversaturation. This problem does not occur in images captured with the updated Aria OS, shown in the right image."}),"\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.img,{alt:"Image",src:t(35554).A+"",width:"1446",height:"528"})}),"\n",(0,i.jsx)(a.p,{children:"Below, we demonstrate how to apply color correction:"}),"\n",(0,i.jsxs)(a.ol,{children:["\n",(0,i.jsx)(a.li,{children:"Set set_color_correction as True (the default value is False)."}),"\n",(0,i.jsx)(a.li,{children:"The output from provider.get_image_data_by_index would be color-corrected."}),"\n"]}),"\n",(0,i.jsxs)(o.default,{groupId:"programming-language",children:[(0,i.jsx)(l.default,{value:"python",label:"Python",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-python",children:'from projectaria_tools.core import data_provider\ncamera_label = "camera-rgb"\nstream_id = provider.get_stream_id_from_label(camera_label)\n\n# turn on color correction\nprovider.set_color_correction(True)\n\n# the output image from get_image_data_by_index will be color corrected\ncolor_corrected_image_array = provider.get_image_data_by_index(stream_id, 0)[0].to_numpy_array()\n'})})}),(0,i.jsx)(l.default,{value:"cpp",label:"C++",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-cpp",children:'#include <dataprovider/VrsDataProvider.h>\n\nstd::string cameraLabel = "camera-rgb";\nvrs::StreamId streamId = provider->getStreamIdFromLabel(cameraLabel);\n\n// turn on color correction\nprovider.setColorCorrection(True);\n\n// the output image from getImageDataByIndex will be color corrected\nImageDataAndRecord imageDataAndRecord = provider.getImageDataByIndex(streamId, 0);\n'})})})]}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.img,{alt:"Image",src:t(3433).A+"",width:"1488",height:"716"}),"\nGo to ",(0,i.jsx)(a.a,{href:"https://github.com/facebookresearch/projectaria_tools/blob/main/core/image/utility/ColorCorrect.cpp",children:"projectaria_tools/core/image/utility/ColorCorrect.cpp"})," for implementation."]}),"\n",(0,i.jsx)(a.h2,{id:"image-devignetting",children:"Image devignetting"}),"\n",(0,i.jsx)(a.p,{children:"Devignetting corrects uneven lighting, enhancing image uniformity and clarity. We provide devignetting for camera-rgb full size image [2880, 2880], camera-rgb half size image[1408, 1408] and slam image [640, 480]."}),"\n",(0,i.jsxs)(a.ol,{children:["\n",(0,i.jsxs)(a.li,{children:["Download ",(0,i.jsx)(a.a,{href:"https://www.projectaria.com/async/sample/download/?bucket=core&filename=devignetting_masks_bin.zip",children:"Aria devignetting masks"})," containing following files:"]}),"\n"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{children:"devignetting_masks_bin\n|- new_isp\n   |- slam_devignetting_mask.bin\n   |- rgb_half_devignetting_mask.bin\n   |- rgb_full_devignetting_mask.bin\n|- old_isp\n   |- slam_devignetting_mask.bin\n   |- rgb_half_devignetting_mask.bin\n   |- rgb_full_devignetting_mask.bin\n"})}),"\n",(0,i.jsxs)(a.ol,{start:"2",children:["\n",(0,i.jsxs)(a.li,{children:["Turn on devignetting. Set devignetting mask folder path with the local aria camera devignetting masks folder path.","\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-python",children:'set_devignetting(True)\nmask_folder_path = "devignetting_masks_bin"\nset_devignetting_mask_folder_path(mask_folder_path)\n'})}),"\n"]}),"\n",(0,i.jsxs)(a.li,{children:["The image data from ",(0,i.jsx)(a.code,{children:"get_image_data_by_index"})," will be devignetted."]}),"\n",(0,i.jsxs)(a.li,{children:["(Optional) If you don't want to devignetting feature, turn off by calling ",(0,i.jsx)(a.code,{children:"set_devignetting(False)"})]}),"\n"]}),"\n",(0,i.jsxs)(o.default,{groupId:"programming-language",children:[(0,i.jsx)(l.default,{value:"python",label:"Python",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-python",children:'from projectaria_tools.core import data_provider\ncamera_label = "camera-rgb"\nstream_id = provider.get_stream_id_from_label(camera_label)\n\n# set devignetting mask path\ndevignetting_mask_folder_path = <FOLDER_PATH_CONTAINING_DEVIGNETTING_MASK>\nprovider.set_devignetting_mask_folder_path(devignetting_mask_folder_path)\n\n# turn on devignetting\nprovider.set_devignetting(True)\n\n# the output image from get_image_data_by_index will be devignetted\ndevignetted_image = provider.get_image_data_by_index(stream_id, 0)\n'})})}),(0,i.jsx)(l.default,{value:"cpp",label:"C++",children:(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-cpp",children:'#include <dataprovider/VrsDataProvider.h>\n\nstd::string cameraLabel = "camera-rgb";\nvrs::StreamId streamId = provider->getStreamIdFromLabel(cameraLabel);\n\nstd::string devignettingMaskFolderPath = <FOLDER_PATH_CONTAINING_DEVIGNETTING_MASK>;\n\n// set devignetting mask path\nprovider.setDevignettingMaskFolderPath(devignettingMaskFolderPath);\n\n// turn on devignetting\nprovider.setDevignetting(true);\n\n// the output image from getImageDataByIndex will be devignetted\nImageDataAndRecord imageDataAndRecord = provider.getImageDataByIndex(streamId, 0);\n'})})})]}),"\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.img,{alt:"Image",src:t(55787).A+"",width:"1414",height:"1084"})}),"\n",(0,i.jsxs)(a.p,{children:["Go to ",(0,i.jsx)(a.a,{href:"https://github.com/facebookresearch/projectaria_tools/blob/main/core/image/utility/Devignetting.cpp",children:"projectaria_tools/core/image/utility/Devignetting.cpp"})," for implementation."]})]})}function u(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}},28453:(e,a,t)=>{t.d(a,{R:()=>o,x:()=>l});var r=t(96540);const i={},n=r.createContext(i);function o(e){const a=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(n.Provider,{value:a},e.children)}},35554:(e,a,t)=>{t.d(a,{A:()=>r});const r=t.p+"assets/images/color_correction_failure-5fa20f5c9a2b44dcfb61afc65e4aa925.png"},49489:(e,a,t)=>{t.r(a),t.d(a,{default:()=>I});var r=t(96540),i=t(34164),n=t(18630),o=t(24245),l=t(56347),s=t(36494),d=t(62814),c=t(45167),m=t(69900);function g(e){return r.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:a}=e;return!!a&&"object"==typeof a&&"value"in a}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function u(e){const{values:a,children:t}=e;return(0,r.useMemo)(()=>{const e=a??function(e){return g(e).map(({props:{value:e,label:a,attributes:t,default:r}})=>({value:e,label:a,attributes:t,default:r}))}(t);return function(e){const a=(0,c.XI)(e,(e,a)=>e.value===a.value);if(a.length>0)throw new Error(`Docusaurus error: Duplicate values "${a.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[a,t])}function p({value:e,tabValues:a}){return a.some(a=>a.value===e)}function h({queryString:e=!1,groupId:a}){const t=(0,l.W6)(),i=function({queryString:e=!1,groupId:a}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:e,groupId:a});return[(0,d.aZ)(i),(0,r.useCallback)(e=>{if(!i)return;const a=new URLSearchParams(t.location.search);a.set(i,e),t.replace({...t.location,search:a.toString()})},[i,t])]}function _(e){const{defaultValue:a,queryString:t=!1,groupId:i}=e,n=u(e),[o,l]=(0,r.useState)(()=>function({defaultValue:e,tabValues:a}){if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${a.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=a.find(e=>e.default)??a[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:a,tabValues:n})),[d,c]=h({queryString:t,groupId:i}),[g,_]=function({groupId:e}){const a=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,i]=(0,m.Dv)(a);return[t,(0,r.useCallback)(e=>{a&&i.set(e)},[a,i])]}({groupId:i}),b=(()=>{const e=d??g;return p({value:e,tabValues:n})?e:null})();(0,s.A)(()=>{b&&l(b)},[b]);return{selectedValue:o,selectValue:(0,r.useCallback)(e=>{if(!p({value:e,tabValues:n}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),_(e)},[c,_,n]),tabValues:n}}var b=t(11062);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(74848);function x({className:e,block:a,selectedValue:t,selectValue:r,tabValues:n}){const l=[],{blockElementScrollPositionUntilNextRender:s}=(0,o.a_)(),d=e=>{const a=e.currentTarget,i=l.indexOf(a),o=n[i].value;o!==t&&(s(a),r(o))},c=e=>{let a=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;a=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;a=l[t]??l[l.length-1];break}}a?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":a},e),children:n.map(({value:e,label:a,attributes:r})=>(0,f.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{l.push(e)},onKeyDown:c,onClick:d,...r,className:(0,i.A)("tabs__item",v.tabItem,r?.className,{"tabs__item--active":t===e}),children:a??e},e))})}function j({lazy:e,children:a,selectedValue:t}){const n=(Array.isArray(a)?a:[a]).filter(Boolean);if(e){const e=n.find(e=>e.props.value===t);return e?(0,r.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:n.map((e,a)=>(0,r.cloneElement)(e,{key:a,hidden:e.props.value!==t}))})}function y(e){const a=_(e);return(0,f.jsxs)("div",{className:(0,i.A)(n.G.tabs.container,"tabs-container",v.tabList),children:[(0,f.jsx)(x,{...a,...e}),(0,f.jsx)(j,{...a,...e})]})}function I(e){const a=(0,b.default)();return(0,f.jsx)(y,{...e,children:g(e.children)},String(a))}},55787:(e,a,t)=>{t.d(a,{A:()=>r});const r=t.p+"assets/images/devignetting-fec0b46f060b6dddfac53f2136e6537b.png"},79317:(e,a,t)=>{t.d(a,{A:()=>r});const r=t.p+"assets/images/undistortion-b8cdb1aa8b6fb5493555936859e284a7.png"},85819:(e,a,t)=>{t.d(a,{A:()=>r});const r=t.p+"assets/images/debayer-94c88a5c2c94e478d18f3ae8f9a33824.png"}}]);