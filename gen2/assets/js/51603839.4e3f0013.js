"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2470],{28453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>a});var n=t(96540);const i={},r=n.createContext(i);function o(e){const s=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:s},e.children)}},93568:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"mps/data_formats/basics","title":"Basics","description":"This page provides an overview of how Project Aria Machine Perception Services (MPS) output files are formatted.","source":"@site/docs-technical-specs/mps/data_formats/basics.mdx","sourceDirName":"mps/data_formats","slug":"/mps/data_formats/basics","permalink":"/projectaria_tools/gen2/technical-specs/mps/data_formats/basics","draft":false,"unlisted":false,"editUrl":"https://www.internalfb.com/code/fbsource/arvr/projects/ariane/aria_research_kit/projectaria_tools/website/docs-technical-specs/mps/data_formats/basics.mdx","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"Basics"},"sidebar":"technicalSpecsSidebar","previous":{"title":"SLAM","permalink":"/projectaria_tools/gen2/technical-specs/mps/data_formats/"},"next":{"title":"Trajectory","permalink":"/projectaria_tools/gen2/technical-specs/mps/data_formats/mps_trajectory"}}');var i=t(74848),r=t(28453);const o={sidebar_position:10,title:"Basics"},a=void 0,l={},c=[{value:"MPS File Structure",id:"mps-file-structure",level:2},{value:"Common terminologies",id:"common-terminologies",level:2},{value:"graph_uid",id:"graph_uid",level:3},{value:"tracking_timestamp_us",id:"tracking_timestamp_us",level:3},{value:"utc_timestamp_ns",id:"utc_timestamp_ns",level:3},{value:"Operator summary",id:"operator-summary",level:2}];function d(e){const s={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.p,{children:["This page provides an overview of how Project Aria ",(0,i.jsx)(s.a,{href:"/ark/mps",children:"Machine Perception Services (MPS)"})," output files are formatted.\nMPS provides derived data generated from Aria raw data (VRS files)."]}),"\n",(0,i.jsx)(s.h2,{id:"mps-file-structure",children:"MPS File Structure"}),"\n",(0,i.jsx)(s.p,{children:"MPS outputs use the following structure, in this example recording1.vrs was used to generate MPS."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"    \u2514\u2500\u2500 Example folder\n        \u251c\u2500\u2500 mps_recording1_vrs\n        \u2502   \u251c\u2500\u2500 slam\n        \u2502   \u2502   \u251c\u2500\u2500 closed_loop_trajectory.csv\n        \u2502   \u2502   \u251c\u2500\u2500 online_calibration.jsonl\n        \u2502   \u2502   \u251c\u2500\u2500 open_loop_trajectory.csv\n        \u2502   \u2502   \u251c\u2500\u2500 semidense_observations.csv.gz\n        \u2502   \u2502   \u251c\u2500\u2500 semidense_points.csv.gz\n        \u2502   \u2502   \u2514\u2500\u2500 summary.json\n        \u2502   \u251c\u2500\u2500 vrs_health_check.json\n        \u2514\u2500\u2500 recording1.vrs\n"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["mps_[name of VRS file]_vrs","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Sibling directory where all the intermediate data and MPS output is saved"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["vrs_health_check.json","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Output of the health check performed on your computer before data is uploaded"}),"\n",(0,i.jsx)(s.li,{children:"Contains information about data drops in all the sensor streams"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["slam folder","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Contains outputs after running SLAM (Trajectory and Semi-Dense Point Cloud data)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"common-terminologies",children:"Common terminologies"}),"\n",(0,i.jsx)(s.h3,{id:"graph_uid",children:"graph_uid"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"graph_uid"})," is a unique identifier for the world coordinate frame. For all the 3D geometric instances like pose and points in the world frames (having _world in the suffix), when they have the same graph_uid, they are in the same coordinate frame."]}),"\n",(0,i.jsx)(s.h3,{id:"tracking_timestamp_us",children:"tracking_timestamp_us"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"tracking_timestamp_us"}),"'s values are shaped by whether it is real world or synthetic data."]}),"\n",(0,i.jsxs)(s.p,{children:["For real world data, ",(0,i.jsx)(s.code,{children:"tracking_timestamp_us"})," provides the Device timestamps from your Aria glasses."]}),"\n",(0,i.jsx)(s.p,{children:"In simulation datasets, this will be the timestamp in the simulator."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"This clock has arbitrary starting points, which are not synchronized between recording sessions or devices."}),"\n",(0,i.jsxs)(s.li,{children:["This clock is strictly monotonic, has stable clock speed, and is accurate in duration","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"If you want to compute the time duration between two timestamps (especially when touching dynamics, e.g. integrating acceleration to velocity over time), you should use this timestamp."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"utc_timestamp_ns",children:"utc_timestamp_ns"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"utc_timestamp_ns"})," is the timestamp from Aria real-time clock (RTC). This time is synchronized to the cell phone time via the Aria Mobile Companion app to get UTC time at the beginning of the recording which is a rough estimate of the external standard clock."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"This clock is not available in the simulation datasets."}),"\n",(0,i.jsx)(s.li,{children:"This clock provides rough synchronization between sessions and devices."}),"\n",(0,i.jsx)(s.li,{children:"This clock is not guaranteed to be monotonic, or have stable clock speed, due to synchronization with NTP. So do not compute duration between two UTC timestamps."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"operator-summary",children:"Operator summary"}),"\n",(0,i.jsx)(s.p,{children:"The operator summary includes individual operator\u2019s status and whether the operation was successful. There are three possible status flags:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"SUCCESS"}),": the operator successfully finished, without known issues."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"WARNING"}),": The operator finished, but internally it detected problem(s) that may affect results quality. The operator still outputs the results, but we don\u2019t have confidence in the quality of the results, so consume the results with caution."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"ERROR"}),": the operator did not finish, finished with major error, or the quality of the results are too bad to be consumed. Results may or may not be generated, and any results should not be consumed."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"The summary also provides information about processes as well as any warning or error messages available"}),"\n",(0,i.jsx)(s.p,{children:"Summary JSON output example:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-json",children:'\n    "SLAM": {\n        "status": "SUCCESS",\n        "info": [\n            "Recording total time: 1104.00s; Trajectory total length: 155.42m",\n            "Total Vision Translational Correction (mm): p50: 0.048; p99: 0.451",\n            "Rotational Correction (deg): p50: 0.001; p99: 0.007"\n        ],\n        "warnings": [],\n        "errors": []\n    },\n...\n'})})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);